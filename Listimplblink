#ifndef THIRD_PARTY_BLINK_RENDERER_CORE_COSMETIC_RULE_H_
#define THIRD_PARTY_BLINK_RENDERER_CORE_COSMETIC_RULE_H_

#include "third_party/blink/renderer/core/dom/element.h"
#include "third_party/blink/renderer/platform/heap/garbage_collected.h"
#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
#include "third_party/blink/renderer/platform/wtf/vector.h"

namespace blink {

// Represents a single cosmetic filtering rule (with one or more selectors).
class CosmeticRule : public GarbageCollected<CosmeticRule> {
 public:
  explicit CosmeticRule(const Vector<String>& raw_selectors);

  const String& Domain() const { return domain_; }
  const Vector<String>& Selectors() const { return selectors_; }
  bool IsException() const { return is_exception_; }
  bool IsGeneric() const { return domain_.IsEmpty(); }

  bool Matches(Element* element) const;  // TODO: implement via SelectorChecker

  void Trace(Visitor* visitor) const {}

 private:
  Vector<String> raw_selectors_;
  String domain_;
  Vector<String> selectors_;
  bool is_exception_ = false;
};

}  // namespace blink

#endif  // THIRD_PARTY_BLINK_RENDERER_CORE_COSMETIC_RULE_H_



#include "third_party/blink/renderer/core/cosmetic_rule.h"

#include "third_party/blink/renderer/platform/wtf/text/string_util.h"

namespace blink {

CosmeticRule::CosmeticRule(const Vector<String>& raw_selectors)
    : raw_selectors_(raw_selectors) {
  // Each entry in raw_selectors_ could be:
  //   "example.com##.ad-banner"
  //   "##.sponsored"
  //   "example.com#@#.overlay"
  //   "#AD_300"

  for (const auto& raw : raw_selectors_) {
    if (raw.Contains("#@#")) {
      is_exception_ = true;
      Vector<String> parts;
      raw.Split("#@#", parts);
      if (parts.size() == 2) {
        domain_ = parts[0].StripWhiteSpace();
        selectors_.push_back(parts[1].StripWhiteSpace());
      } else {
        selectors_.push_back(raw.StripWhiteSpace());
      }
    } else if (raw.Contains("##")) {
      Vector<String> parts;
      raw.Split("##", parts);
      if (parts.size() == 2) {
        domain_ = parts[0].StripWhiteSpace();
        selectors_.push_back(parts[1].StripWhiteSpace());
      } else {
        selectors_.push_back(raw.StripWhiteSpace());
      }
    } else {
      // Generic selector only
      selectors_.push_back(raw.StripWhiteSpace());
    }
  }
}

bool CosmeticRule::Matches(Element* element) const {
  // TODO: integrate with SelectorChecker.
  // For now, safe stub:
  return false;
}

}  // namespace blink
