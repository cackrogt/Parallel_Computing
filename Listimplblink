#ifndef THIRD_PARTY_BLINK_RENDERER_CORE_COSMETIC_RULE_H_
#define THIRD_PARTY_BLINK_RENDERER_CORE_COSMETIC_RULE_H_

#include "third_party/blink/renderer/core/dom/element.h"
#include "third_party/blink/renderer/platform/heap/garbage_collected.h"
#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
#include "third_party/blink/renderer/platform/wtf/vector.h"

namespace blink {

// Represents a single cosmetic filtering rule (with one or more selectors).
class CosmeticRule : public GarbageCollected<CosmeticRule> {
 public:
  explicit CosmeticRule(const Vector<String>& raw_selectors);

  const String& Domain() const { return domain_; }
  const Vector<String>& Selectors() const { return selectors_; }
  bool IsException() const { return is_exception_; }
  bool IsGeneric() const { return domain_.IsEmpty(); }

  bool Matches(Element* element) const;  // TODO: implement via SelectorChecker

  void Trace(Visitor* visitor) const {}

 private:
  Vector<String> raw_selectors_;
  String domain_;
  Vector<String> selectors_;
  bool is_exception_ = false;
};

}  // namespace blink

#endif  // THIRD_PARTY_BLINK_RENDERER_CORE_COSMETIC_RULE_H_



#include "third_party/blink/renderer/core/cosmetic_rule.h"

#include "third_party/blink/renderer/platform/wtf/text/string_util.h"

namespace blink {

CosmeticRule::CosmeticRule(const Vector<String>& raw_selectors)
    : raw_selectors_(raw_selectors) {
  // Each entry in raw_selectors_ could be:
  //   "example.com##.ad-banner"
  //   "##.sponsored"
  //   "example.com#@#.overlay"
  //   "#AD_300"

  for (const auto& raw : raw_selectors_) {
    if (raw.Contains("#@#")) {
      is_exception_ = true;
      Vector<String> parts;
      raw.Split("#@#", parts);
      if (parts.size() == 2) {
        domain_ = parts[0].StripWhiteSpace();
        selectors_.push_back(parts[1].StripWhiteSpace());
      } else {
        selectors_.push_back(raw.StripWhiteSpace());
      }
    } else if (raw.Contains("##")) {
      Vector<String> parts;
      raw.Split("##", parts);
      if (parts.size() == 2) {
        domain_ = parts[0].StripWhiteSpace();
        selectors_.push_back(parts[1].StripWhiteSpace());
      } else {
        selectors_.push_back(raw.StripWhiteSpace());
      }
    } else {
      // Generic selector only
      selectors_.push_back(raw.StripWhiteSpace());
    }
  }
}

bool CosmeticRule::Matches(Element* element) const {
  // TODO: integrate with SelectorChecker.
  // For now, safe stub:
  return false;
}

}  // namespace blink

void Document::SetupActiveCosmeticFilters() {
  active_cosmetic_filters_.clear();

  String host = Url().Host();

  for (auto& rule : kParsedCosmeticFilters1) {
    if (rule->IsException())
      continue; // handle separately if needed

    if (rule->IsGeneric() || host.EndsWith(rule->Domain())) {
      active_cosmetic_filters_.push_back(rule);
    }
  }
}


bool CosmeticRule::Matches(Element* element) const {
  // TODO: Replace with Blink's real SelectorChecker later.
  // For now: simple string comparisons on ID/Class/Style.

  for (const auto& selector : selectors_) {
    if (selector.StartsWith("#")) {
      // Match ID
      if (element->getIdAttribute() == selector.Substring(1))
        return true;
    } else if (selector.StartsWith(".")) {
      // Match class name (split by whitespace)
      AtomicString class_attr = element->getAttribute(html_names::kClassAttr);
      if (!class_attr.IsNull() && class_attr.GetString().Contains(selector.Substring(1)))
        return true;
    } else if (selector.StartsWith("[")) {
      // Very naive attribute match, e.g. [style*="foo"]
      AtomicString style_attr = element->getAttribute(html_names::kStyleAttr);
      if (!style_attr.IsNull() && style_attr.GetString().Contains("foo"))
        return true;
    }
    // More complex selectors need SelectorChecker.
  }

  return false;
}

void Document::TraverseElements(Element* root) {
  if (!root)
    return;

  for (Element* el = root; el; el = el->NextElementSibling()) {
    // Check active cosmetic filters
    for (auto& rule : active_cosmetic_filters_) {
      if (rule->Matches(el)) {
        // Hide element
        el->setInlineStyleProperty(
            CSSPropertyDisplay, "none",
            SecureContextMode::kNotSecureContext);
      }
    }

    // Recurse into children
    if (Element* child = el->firstElementChild())
      TraverseElements(child);
  }
}



#include "third_party/blink/renderer/core/dom/element.h"
#include "third_party/blink/renderer/core/html_names.h"

namespace blink {

bool CosmeticRule::Matches(Element* element) const {
  for (const auto& selector : selectors_) {
    if (selector.StartsWith("#")) {
      // Match ID selector
      if (element->getIdAttribute() == selector.Substring(1))
        return true;

    } else if (selector.StartsWith(".")) {
      // Match class selector
      AtomicString class_attr = element->getAttribute(html_names::kClassAttr);
      if (!class_attr.IsNull() &&
          class_attr.GetString().Contains(selector.Substring(1)))
        return true;

    } else if (selector.StartsWith("[")) {
      // Very basic attribute match: e.g. [style*="content-visibility: visible"]
      // We look for '*=' substring syntax.
      wtf_size_t star_eq = selector.Find("*=");
      if (star_eq != kNotFound) {
        // Extract attribute name and value inside quotes
        String attr_name = selector.Substring(1, star_eq - 1).StripWhiteSpace();
        String value = selector.Substring(star_eq + 2).StripWhiteSpace();

        if (value.StartsWith("\"") && value.EndsWith("\""))
          value = value.Substring(1, value.length() - 2);  // strip quotes

        AtomicString attr_val = element->getAttribute(AtomicString(attr_name));
        if (!attr_val.IsNull() && attr_val.GetString().Contains(value))
          return true;
      }
    }
    // TODO: More cases (full selector matching via SelectorChecker).
  }
  return false;
}

}  // namespace blink
