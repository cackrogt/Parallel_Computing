Perfect ‚Äî this is exactly where things get really interesting.

Let‚Äôs peel this apart in detail ‚Äî how prerendering actually works inside Chromium, and how it relates (and differs) from a normal navigation flow driven by the NavigationController and RenderFrameHostImpl.


---

üß≠ 1. The ‚ÄúNormal‚Äù Navigation Flow

Let‚Äôs first briefly recap how normal navigation works in Chromium:

When you click a link or type a URL:

1. NavigationController::LoadURL() is called in the browser process.


2. It creates a NavigationRequest, managed by Navigator.


3. That triggers:

URL validation (same-origin, sandbox rules)

Policy checks

SiteInstance selection



4. Once approved, the browser process tells the renderer to start loading.


5. The renderer calls back with:

DidStartProvisionalLoad

DidCommitNavigation



6. A new RenderFrameHostImpl may be created (if cross-site).


7. The page becomes visible in a WebContents.



Everything happens synchronously from the user‚Äôs action ‚Äî and the page load blocks the visible tab until complete.


---

‚ö° 2. Now: Prerendering Overview

Prerendering reuses almost all of the same machinery ‚Äî NavigationController, RenderFrameHostImpl, network stack, etc.
But the key difference is:

> The prerendered page is loaded speculatively in an isolated, hidden WebContents, not shown to the user yet.



It‚Äôs like doing a full navigation ‚Äî but sandboxed and invisible ‚Äî so that if the user actually navigates to that page, the tab can instantly ‚Äúswap in‚Äù that preloaded content instead of reloading from scratch.


---

‚öôÔ∏è 3. Step-by-Step: What Happens When Chrome Starts a Prerender

Let‚Äôs use omnibox prerendering as the example trigger.

Step 1 ‚Äî Predictor decides to prerender

AutocompleteActionPredictor calls:

prerender_manager->AddPrerenderFromOmnibox(url, session_storage_namespace, size);

Step 2 ‚Äî PrerenderManager creates a PrerenderContents

PrerenderManager lives in: chrome/browser/prerender/prerender_manager.cc

It owns multiple PrerenderContents ‚Äî one per prerendered page.

It:

Creates a new WebContents object (hidden)

Initializes a NavigationController

Sets up a SessionStorageNamespace

Calls NavigationController::LoadURLWithParams()


‚úÖ So ‚Äî this starts a real navigation, identical to normal browsing, but directed into a hidden, non-visible WebContents.


---

Step 3 ‚Äî Navigation starts like normal

The prerendered WebContents creates a normal NavigationRequest:

Goes through NavigationController ‚Üí Navigator ‚Üí FrameTreeNode

The browser and renderer perform normal network requests and page loading

All renderers, scripts, subresources are loaded


However:

The WebContents is not attached to the visible UI.

The renderer‚Äôs frame is created in a hidden, throttled state.

Certain APIs (dialogs, permission prompts, window.open, etc.) are disabled or deferred.



---

Step 4 ‚Äî Prerender restrictions enforced

Prerendered pages must behave as if they are invisible until activation:

document.visibilityState = "prerender"

window.onvisibilitychange can fire when activated

Some APIs (e.g., alert(), confirm(), requestFullscreen(), open()) are blocked

Storage access, cookies, fetch requests still work ‚Äî because they‚Äôre real loads

JavaScript still executes ‚Äî but with throttled timers and no paint


All this is managed by:

content/browser/prerender/prerender_host_impl.cc
content/browser/prerender/prerender_host_registry.cc

These are the modern replacements for older PrerenderManager.


---

Step 5 ‚Äî Activation (User Navigates to That URL)

When the user finally navigates (say, presses Enter or clicks that same suggestion):

1. NavigationController compares the target URL to existing prerendered entries (via PrerenderHostRegistry::FindHostByUrl()).


2. If a matching prerender exists:

Chrome cancels the new navigation request.

It activates the prerendered WebContents instead.




Activation process:

The prerendered RenderFrameHostImpl becomes the primary one in the visible WebContents.

Visibility is switched: document.visibilityState changes to "visible".

Paint suppression lifted ‚Äî content appears instantly.

Lifecycle observers (onpageshow, etc.) fire as usual.


This activation is essentially a WebContents swap:

RenderFrameHostManager::CommitPrerenderNavigation()

is called instead of creating a new frame.

So to the user, the tab simply ‚Äúsnaps‚Äù to the loaded page instantly.


---

Step 6 ‚Äî Cleanup

Once activated:

The old prerender host is removed from PrerenderHostRegistry.

All other prerenders are canceled (only one prerender is ever active at once).

Resources (memory, network handles) are released.


If the user never navigates to the prerendered URL:

It times out (few seconds)

Or gets evicted under memory pressure

Or canceled when typing changes in the omnibox



---

üß© 4. Architectural Layers Involved

Layer	Key Classes / Files	Purpose

Omnibox trigger	AutocompleteActionPredictor, PrerenderManager	Decides to prerender a page
Browser process	PrerenderHostRegistry, PrerenderHostImpl	Manages prerender sessions and activation
Navigation stack	NavigationController, NavigationRequest, FrameTreeNode	Performs actual hidden navigation
Renderer process	RenderFrameHostImpl, DocumentLoader, WebFrame	Loads the page invisibly
Activation path	CommitPrerenderNavigation, RenderFrameHostManager	Swaps hidden prerender into visible tab



---

üß† 5. Similarities vs Differences to Normal Navigation

Aspect	Normal Navigation	Prerendering

Navigation flow	Triggered by user	Triggered speculatively (hidden)
NavigationController	Yes	Yes (per hidden WebContents)
Network loading	Real	Real
Renderer work	Full parse, JS, layout	Full, but offscreen
Visibility	Visible	Hidden (document.visibilityState = "prerender")
Activation	Immediate	Only on URL match
Resource cost	Normal	Extra memory & CPU
Number concurrent	Unlimited tabs	Usually 1 prerender per profile/tab context
APIs available	All	Some blocked (dialogs, window management)



---

üîí 6. Modern Prerendering Architecture (Speculation Rules API)

Since Chrome 108+, omnibox prerendering internally reuses the Speculation Rules / Prerender2 system, under:

content/browser/speculation_rules/
content/browser/prerender/

This allows:

Pages to declare their own prerenders (<script type="speculationrules">)

The omnibox predictor to also feed prerenders through the same unified pipeline.


So now omnibox prerenders and speculation prerenders share the same host registry and activation mechanism.


---

üí° Summary Analogy

Imagine Chrome has a parallel invisible browser tab:

It goes through all the normal loading phases.

It runs all JS and network requests.

But it‚Äôs ‚Äúpaused‚Äù right before painting to screen.

If you actually navigate there, Chrome just shows that already-loaded tab.


That‚Äôs prerendering in a nutshell.


---

üß© TL;DR Summary

Step	What Happens

1Ô∏è‚É£	Predictor picks a high-confidence URL
2Ô∏è‚É£	PrerenderManager creates hidden WebContents
3Ô∏è‚É£	Page loads fully but stays invisible
4Ô∏è‚É£	Renderer executes JS, network fetches complete
5Ô∏è‚É£	If user navigates ‚Üí instant activation
6Ô∏è‚É£	Otherwise canceled or timed out



---

Would you like me to show the exact activation sequence ‚Äî i.e. how the prerendered RenderFrameHostImpl is swapped into the active one (the internal CommitPrerenderNavigation() flow)?
That‚Äôs where the deep linkage to NavigationController and FrameTree really happens.


















Perfect ‚Äî this is exactly where things get really interesting.

Let‚Äôs peel this apart in detail ‚Äî how prerendering actually works inside Chromium, and how it relates (and differs) from a normal navigation flow driven by the NavigationController and RenderFrameHostImpl.


---

üß≠ 1. The ‚ÄúNormal‚Äù Navigation Flow

Let‚Äôs first briefly recap how normal navigation works in Chromium:

When you click a link or type a URL:

1. NavigationController::LoadURL() is called in the browser process.


2. It creates a NavigationRequest, managed by Navigator.


3. That triggers:

URL validation (same-origin, sandbox rules)

Policy checks

SiteInstance selection



4. Once approved, the browser process tells the renderer to start loading.


5. The renderer calls back with:

DidStartProvisionalLoad

DidCommitNavigation



6. A new RenderFrameHostImpl may be created (if cross-site).


7. The page becomes visible in a WebContents.



Everything happens synchronously from the user‚Äôs action ‚Äî and the page load blocks the visible tab until complete.


---

‚ö° 2. Now: Prerendering Overview

Prerendering reuses almost all of the same machinery ‚Äî NavigationController, RenderFrameHostImpl, network stack, etc.
But the key difference is:

> The prerendered page is loaded speculatively in an isolated, hidden WebContents, not shown to the user yet.



It‚Äôs like doing a full navigation ‚Äî but sandboxed and invisible ‚Äî so that if the user actually navigates to that page, the tab can instantly ‚Äúswap in‚Äù that preloaded content instead of reloading from scratch.


---

‚öôÔ∏è 3. Step-by-Step: What Happens When Chrome Starts a Prerender

Let‚Äôs use omnibox prerendering as the example trigger.

Step 1 ‚Äî Predictor decides to prerender

AutocompleteActionPredictor calls:

prerender_manager->AddPrerenderFromOmnibox(url, session_storage_namespace, size);

Step 2 ‚Äî PrerenderManager creates a PrerenderContents

PrerenderManager lives in: chrome/browser/prerender/prerender_manager.cc

It owns multiple PrerenderContents ‚Äî one per prerendered page.

It:

Creates a new WebContents object (hidden)

Initializes a NavigationController

Sets up a SessionStorageNamespace

Calls NavigationController::LoadURLWithParams()


‚úÖ So ‚Äî this starts a real navigation, identical to normal browsing, but directed into a hidden, non-visible WebContents.


---

Step 3 ‚Äî Navigation starts like normal

The prerendered WebContents creates a normal NavigationRequest:

Goes through NavigationController ‚Üí Navigator ‚Üí FrameTreeNode

The browser and renderer perform normal network requests and page loading

All renderers, scripts, subresources are loaded


However:

The WebContents is not attached to the visible UI.

The renderer‚Äôs frame is created in a hidden, throttled state.

Certain APIs (dialogs, permission prompts, window.open, etc.) are disabled or deferred.



---

Step 4 ‚Äî Prerender restrictions enforced

Prerendered pages must behave as if they are invisible until activation:

document.visibilityState = "prerender"

window.onvisibilitychange can fire when activated

Some APIs (e.g., alert(), confirm(), requestFullscreen(), open()) are blocked

Storage access, cookies, fetch requests still work ‚Äî because they‚Äôre real loads

JavaScript still executes ‚Äî but with throttled timers and no paint


All this is managed by:

content/browser/prerender/prerender_host_impl.cc
content/browser/prerender/prerender_host_registry.cc

These are the modern replacements for older PrerenderManager.


---

Step 5 ‚Äî Activation (User Navigates to That URL)

When the user finally navigates (say, presses Enter or clicks that same suggestion):

1. NavigationController compares the target URL to existing prerendered entries (via PrerenderHostRegistry::FindHostByUrl()).


2. If a matching prerender exists:

Chrome cancels the new navigation request.

It activates the prerendered WebContents instead.




Activation process:

The prerendered RenderFrameHostImpl becomes the primary one in the visible WebContents.

Visibility is switched: document.visibilityState changes to "visible".

Paint suppression lifted ‚Äî content appears instantly.

Lifecycle observers (onpageshow, etc.) fire as usual.


This activation is essentially a WebContents swap:

RenderFrameHostManager::CommitPrerenderNavigation()

is called instead of creating a new frame.

So to the user, the tab simply ‚Äúsnaps‚Äù to the loaded page instantly.


---

Step 6 ‚Äî Cleanup

Once activated:

The old prerender host is removed from PrerenderHostRegistry.

All other prerenders are canceled (only one prerender is ever active at once).

Resources (memory, network handles) are released.


If the user never navigates to the prerendered URL:

It times out (few seconds)

Or gets evicted under memory pressure

Or canceled when typing changes in the omnibox



---

üß© 4. Architectural Layers Involved

Layer	Key Classes / Files	Purpose

Omnibox trigger	AutocompleteActionPredictor, PrerenderManager	Decides to prerender a page
Browser process	PrerenderHostRegistry, PrerenderHostImpl	Manages prerender sessions and activation
Navigation stack	NavigationController, NavigationRequest, FrameTreeNode	Performs actual hidden navigation
Renderer process	RenderFrameHostImpl, DocumentLoader, WebFrame	Loads the page invisibly
Activation path	CommitPrerenderNavigation, RenderFrameHostManager	Swaps hidden prerender into visible tab



---

üß† 5. Similarities vs Differences to Normal Navigation

Aspect	Normal Navigation	Prerendering

Navigation flow	Triggered by user	Triggered speculatively (hidden)
NavigationController	Yes	Yes (per hidden WebContents)
Network loading	Real	Real
Renderer work	Full parse, JS, layout	Full, but offscreen
Visibility	Visible	Hidden (document.visibilityState = "prerender")
Activation	Immediate	Only on URL match
Resource cost	Normal	Extra memory & CPU
Number concurrent	Unlimited tabs	Usually 1 prerender per profile/tab context
APIs available	All	Some blocked (dialogs, window management)



---

üîí 6. Modern Prerendering Architecture (Speculation Rules API)

Since Chrome 108+, omnibox prerendering internally reuses the Speculation Rules / Prerender2 system, under:

content/browser/speculation_rules/
content/browser/prerender/

This allows:

Pages to declare their own prerenders (<script type="speculationrules">)

The omnibox predictor to also feed prerenders through the same unified pipeline.


So now omnibox prerenders and speculation prerenders share the same host registry and activation mechanism.


---

üí° Summary Analogy

Imagine Chrome has a parallel invisible browser tab:

It goes through all the normal loading phases.

It runs all JS and network requests.

But it‚Äôs ‚Äúpaused‚Äù right before painting to screen.

If you actually navigate there, Chrome just shows that already-loaded tab.


That‚Äôs prerendering in a nutshell.


---

üß© TL;DR Summary

Step	What Happens

1Ô∏è‚É£	Predictor picks a high-confidence URL
2Ô∏è‚É£	PrerenderManager creates hidden WebContents
3Ô∏è‚É£	Page loads fully but stays invisible
4Ô∏è‚É£	Renderer executes JS, network fetches complete
5Ô∏è‚É£	If user navigates ‚Üí instant activation
6Ô∏è‚É£	Otherwise canceled or timed out



---

Would you like me to show the exact activation sequence ‚Äî i.e. how the prerendered RenderFrameHostImpl is swapped into the active one (the internal CommitPrerenderNavigation() flow)?
That‚Äôs where the deep linkage to NavigationController and FrameTree really happens.










Here is a detailed walkthrough of the prerendering pipeline in the context of the omnibox (address‚Äêbar) in Chromium / Chrome, with specific focus on the logic in the AutocompleteActionPredictor and how it ties into the larger prerendering machinery. I‚Äôll start by summarizing the high-level steps, then go into the key components and flow, pointing to the relevant code (in autocomplete_action_predictor.cc) and design docs.


---

High-Level Overview

When a user types in the omnibox, Chromium is trying to predict what URL the user will navigate to. If the confidence is sufficiently high, the browser may preconnect or even prerender that predicted URL so that if the user accepts it, the navigation will be much faster. The pipeline can be broken down roughly into the following steps:

1. User types in Omnibox ‚Üí suggestions appear and predictive hints are computed (via AutocompleteController, etc).


2. The AutocompleteActionPredictor monitors these events: it keeps track of what the user typed (user_text) and which match (destination URL) was selected. It records those ‚Äútransitional matches‚Äù (possible candidate URLs) and their outcomes (whether they were actually navigated to).


3. For each suggestion (match) it computes a confidence based on historical data (how often given user_text + URL resulted in a navigation).


4. Based on that confidence, it assigns an action: none, preconnect, or prerender (or perhaps other actions).


5. If the action is prerender, then StartPrerendering(...) is invoked which forwards to the PrerenderManager.


6. Meanwhile, when the user actually opens a URL (via popup choice or pressing enter), OnOmniboxOpenedUrl(...) is invoked in the predictor, which handles tying the navigation event back to the predictor table (learning) and also cancels or transitions any ongoing prerender that was speculative.


7. The PrerenderManager handles the lifecycle of the prerendered page: launching a hidden/background (off‚Äêscreen) navigation, loading resources, and later when user hits the URL, ‚Äúactivating‚Äù the prerendered page (swap it into the visible tab) so as to reduce latency.


8. There are many constraints and heuristics in place: e.g., only certain types of matches are eligible (not every suggestion), prerendering may be disabled in certain profiles/contexts, search suggestions may be treated differently, resource constraints, etc.


9. Over time the AutocompleteActionPredictor updates its database/table of (user_text, URL) ‚Üí hits/misses, so future predictions can be more accurate.




---

Key Components (with emphasis on Omnibox context)

Here are the main pieces and how they fit together:

AutocompleteActionPredictor

This class lives in chrome/browser/predictors/autocomplete_action_predictor.cc. 

It maintains:

transitional_matches_ ‚Äî a vector of entries each storing a user_text (lower-case) and a list of candidate URLs seen in the suggestion list. 

db_cache_, db_id_cache_ ‚Äî in‚Äêmemory caches of the persistent predictor database (rows mapping (user_text, URL) ‚Üí number_of_hits / number_of_misses) loaded from AutocompleteActionPredictorTable. 


On user input: RegisterTransitionalMatches(user_text, result) is called (not shown in the excerpt but present) to record what matches were shown.

When a navigation from the omnibox actually happens: OnOmniboxOpenedUrl(const OmniboxLog& log) is called. This handles:

1. Abandoning any in‚Äêflight prerender handle via OnNavigateAway() on the prerender_handle_. 


2. For each transitional match whose user_text is a prefix of log.text, it creates/updates rows in the database: it determines whether each candidate URL in that transitional match equals the opened URL (hit) or not (miss), and then updates the DB cache and table accordingly. 


3. Clears the transitional_matches_ vector for the next input session. 



Before starting prerendering, the method RecommendAction(user_text, match) is used. It computes a confidence (via CalculateConfidence) and then maps it to an action: NONE, PRECONNECT, or PRERENDER. 

Confidence is simply: if there is a row in the DB for (user_text, URL), and number_of_hits >= minimum (3), then: hits / (hits + misses). 

If confidence ‚â• kConfidenceCutoff[i] then action is i, where the array of cutoffs is something like {0.8f, 0.5f}. 

Important: If the predicted URL is a search type match (e.g., the suggestion is a search query rather than a direct URL navigation) OR prerendering in omnibox is disabled for the profile, then the action is downgraded from PRERENDER to PRECONNECT. 


Starting prerender: StartPrerendering(url, session_storage_namespace, size) is invoked. It uses PrerenderManagerFactory::GetForBrowserContext(profile_) to get the manager and calls AddPrerenderFromOmnibox(...). Also it doesn‚Äôt cancel the old prerender until after starting the new one (so that if URL is same, underlying prerender may be reused). 

Cancelling prerender: CancelPrerender() triggers prerender_handle_->OnCancel() if present and not yet abandoned. 


PrerenderManager & PrerenderHandle

The PrerenderManager is responsible for managing speculative prerender navigations. It lives under chrome/browser/prerender/. In the call above, AddPrerenderFromOmnibox(...) launches a prerender initiated from the omnibox context. 

The PrerenderHandle object is returned and tracks the lifecycle of a prerender. It can be cancelled, abandoned, or activated when the real navigation happens.

The design doc ‚ÄúPrerender pages in Chrome for instant page navigations‚Äù describes how when typing a URL in the omnibox, Chrome may automatically prerender the page. 

That design doc says: ‚ÄúWhen you type a URL into the Chrome address bar (also known as ‚Äòthe omnibox‚Äô), Chrome may automatically prerender the page for you, if it has high confidence you will visit that page.‚Äù 

It also states that for high confidence (>50% in their example) prerendering is triggered, for medium confidence (>30%) just preconnect added. 



Omnibox / Autocomplete interaction

As the user types, the omnibox suggestions appear (handled in AutocompleteController). 

The predictor monitors suggestion lists (via transitional matches) and learns from which suggestion URLs were eventually navigated to.

When a suggestion is selected (via UI or enter), OnOmniboxOpenedUrl is called. Note: only certain cases qualify (pop-up must be open, not a paste‚Äêand‚Äêgo) to avoid spurious data. 



---

Detailed Flow in Omnibox Context

Here is a more step‚Äêby‚Äêstep timeline of what happens, with emphasis on the ‚Äúomnibox context‚Äù scenario: user types ‚Üí suggestion ‚Üí maybe prerender ‚Üí navigation.

1. User enters text in omnibox

Suppose a user types ‚Äúgit‚Äù in the omnibox. The AutocompleteController queries providers (history URLs, omnibox suggestions, search suggestions, etc) and builds a list of AutocompleteMatch objects (each has destination_url, type, etc). 

At some point (after suggestion list is built) the predictor‚Äôs RegisterTransitionalMatches(user_text, result) is called. This captures the current user_text (lower-cased) and the list of candidate URLs (from result). These are stored in transitional_matches_.



2. Predictor evaluates matches (optional)

For each candidate match (suggestion) the predictor may compute RecommendAction(user_text, match), which returns an action NONE, PRECONNECT, or PRERENDER.

If the action chosen is PRERENDER, StartPrerendering(...) is invoked immediately (or soon). That triggers a /AddPrerenderFromOmnibox(url, session_namespace, size) call on PrerenderManager.

The parameters: url is the candidate match‚Äôs destination_url, session_storage_namespace is needed to ensure session state (if any) is preserved, and size is the current tab‚Äôs size (so prerendering knows layout context) ‚Äî as seen in StartPrerendering. 

If a previous prerender handle exists, the code moves it out (old_prerender_handle = std::move(prerender_handle_)), then requests the new prerender, and then cancels the old one (via old_prerender_handle->OnCancel()). This ensures that if the same URL is reused, the same underlying prerender may continue. 



3. Speculative prerendering underway

The PrerenderManager takes the prerender request and sets up a hidden/off‚Äêscreen navigation of the given URL.

The page begins loading resources (HTML, JS, CSS, etc) but is not yet made visible. Some APIs (prompts, dialogs) may be suppressed or delayed until activation. The design doc explains this in general. 

The prerender handle monitors cancellation, abandonment, or activation.

Meanwhile, the user may still be typing or may change their mind; hence the speculative prerender could be cancelled if user navigates elsewhere or the conditions change (memory pressure, user modifies input, user picks something else). The predictor‚Äôs CancelPrerender() can be invoked to do so.



4. User navigates / selects suggestion

At some point the user selects a suggestion (by clicking or pressing enter). The OmniboxLog structure is built (with log.text, log.result, log.selected_index, etc). The predictor‚Äôs OnOmniboxOpenedUrl(log) is called. 

In OnOmniboxOpenedUrl:

It checks that initialized_ is true, that log.text.length() >= minimum, that the popup was open (log.is_popup_open), that it‚Äôs not a paste‚Äêand‚Äêgo (log.is_paste_and_go). If these conditions fail, nothing is learned. 

If a prerender handle exists, it calls prerender_handle_->OnNavigateAway() (not full cancel), thereby telling the handle that navigation is now going to happen (or user left the input) and the remaining time before activation is shorter. It does not yet release prerender_handle_, so that if StartPrerendering is called again soon, the handle may still be valid. 

It logs a UMA histogram: "Prerender.OmniboxNavigationsCouldPrerender" with value IsOmniboxEnabled(profile_). This helps monitor how often omnibox‚Äêinitiated navigations had prerendering enabled. 

It then finds the selected match: match = log.result.match_at(log.selected_index), opened_url = match.destination_url.

It converts the user text to lowercase: lower_user_text = ToLower(log.text).

It then iterates all transitional_matches_. For each entry where user_text is a prefix of lower_user_text, it loops all the URLs in that entry and for each forms a key (user_text, url). If the url equals opened_url, it‚Äôs a hit; otherwise a miss. It then populates lists rows_to_add or rows_to_update accordingly. 

After building those rows, it calls AddAndUpdateRows(rows_to_add, rows_to_update) which updates db_cache_, db_id_cache_ and also posts tasks to update the underlying DB table. 

Clears transitional_matches_.

It then iterates tracked_urls_ (which were URLs recorded when RecommendAction was called) and logs whether the opened_url matches what was tracked, for analytics. 




5. Activation of prerender (if used)

If the prerendered URL is indeed the one the user navigated to, the hidden prerendered page can be ‚Äúactivated‚Äù: the hidden WebContents is swapped in or converted to the foreground tab, thereby giving the user nearly instantaneous load (since the page is already loaded or partially loaded). The design doc discusses this: 

If the prerender is not used (for example user navigated to a different URL), the prerender will be cancelled or abandoned, freeing memory/ resources.



6. Constraints / Heuristics / Downgrade logic

In RecommendAction, after deciding that action is ACTION_PRERENDER, the code checks:

if (action == ACTION_PRERENDER &&
    (AutocompleteMatch::IsSearchType(match.type) ||
     !prerender::IsOmniboxEnabled(profile_))) {
  action = ACTION_PRECONNECT;
}

So: if the match is a search suggestion (rather than a direct URL) or prerendering via omnibox is disabled for this profile, then we downgrade prerender to preconnect. 

This is because search result pages may not be safe/efficient to prerender (server might not expect it, side‚Äêeffects, etc) and also because users may disable speculative prerendering (or feature flag).

The design doc says: when user types a URL, Chrome may prerender if high confidence; if just a search term then perhaps only preconnect. 



7. Learning / Database update

Over time, the predictor builds up evidence (hits vs misses) for pairs (user_text, destination_url).

The confidence formula: if number_of_hits ‚â• minimum (3) then confidence = hits / (hits + misses). Otherwise confidence = 0.0. 

The cutoffs kConfidenceCutoff[] = {0.8f, 0.5f} map to actions: if confidence ‚â• 0.8 ‚Üí PRERENDER (if eligible), else if confidence ‚â• 0.5 ‚Üí PRECONNECT, else NONE. (The exact mapping may vary by build). 

The table is maintained via AutocompleteActionPredictorTable.





---

Specific Notes / Edge Cases for Omnibox Context

Since you‚Äôre specifically interested in the omnibox context, here are some extra relevant aspects:

Only omnibox‚Äêinitiated navigations trigger this pipeline (i.e., typed or suggestion selected). Bookmark or link click navigations are out of scope of this predictor.

The StartPrerendering call uses AddPrerenderFromOmnibox, which is a specialization of prerender initiation catering to the omnibox scenario (versus e.g., link hover or speculation rules).

Because the omnibox may show search suggestions or direct URL completions, the predictor checks if the match is of ‚Äúsearch type‚Äù (via AutocompleteMatch::IsSearchType(match.type)). If so, it avoids full prerender due to reliability and server side concerns. 

Session storage namespace is passed into prerender initiation ‚Äî this ensures that the prerendered page uses the correct session (tabs/back‚Äêforward) context (so e.g., session storage works).

Because typing may change mid‚Äêstream, the predictor ensures that old prerenders are cancelled (or signalled away) when a new navigation happens.

The design doc on omnibox prerendering mentions that the ‚Äúchrome://predictors‚Äù page lets you view address bar predictions and their confidence levels. 

There are memory/bandwidth constraints: even though prerendering can lead to near‚Äêinstant loads, it uses more resources, so it's only triggered when confidence is high and user settings permit it. The doc says >50% confidence is typical for prerender, >30% for preconnect. 



---

Summary of the ‚ÄúPipeline‚Äù in the Code You Tagged (prerender start)

Let‚Äôs tie the specific code snippet you referenced (in autocomplete_action_predictor.cc, the StartPrerendering call near line 201) into the above flow:

At the point where the predictor decides to prerender (via RecommendAction returning ACTION_PRERENDER), the method StartPrerendering(url, session_storage_namespace, size) is invoked.

Implementation:

void AutocompleteActionPredictor::StartPrerendering(
    const GURL& url,
    content::SessionStorageNamespace* session_storage_namespace,
    const gfx::Size& size) {
  // Only cancel the old prerender after starting the new one, so if the URLs
  // are the same, the underlying prerender will be reused.
  std::unique_ptr<prerender::PrerenderHandle> old_prerender_handle =
      std::move(prerender_handle_);
  prerender::PrerenderManager* prerender_manager =
      prerender::PrerenderManagerFactory::GetForBrowserContext(profile_);
  if (prerender_manager) {
    prerender_handle_ = prerender_manager->AddPrerenderFromOmnibox(
        url, session_storage_namespace, size);
  }
  if (old_prerender_handle)
    old_prerender_handle->OnCancel();
}

This ensures any previously scheduled prerender is cancelled only after the new one is requested.

The new prerender_handle_ holds the handle for the new speculative prerender (if any).

The call uses AddPrerenderFromOmnibox(...) specifically for omnibox-initiated prerenders.


Later, when OnOmniboxOpenedUrl(...) happens (user actually navigates), the predictor signals the prerender handle via OnNavigateAway, letting the manager know that navigation is incoming (which may speed up activation) or maybe trigger reuse.



---

What this means for you (if you are working with Blink / WebView / WebView embedding)

If you embed a Chromium‚Äêbased WebView or modify the omnibox/predictor behaviour, understanding this pipeline means you can reason about when and how prerendering may be triggered (or disabled) for address‚Äêbar inputs.

For example, if you disable IsOmniboxEnabled(profile_), then the predictor will automatically downgrade to preconnect instead of prerender. So you might want to expose a flag for that in your embed if you want to control speculative prerendering.

If your web content uses sessionStorage or other storage APIs, note that the sessionStorage namespace is forwarded into the prerender request (so that the speculative prerender is in the correct session context).

If you are concerned about memory usage, resource overhead, or want to observe when prerenders happen/cancel, you might instrument the PrerenderHandle lifecycle or observe chrome://predictors (in desktop) to see the confidence levels.

If your focus is the omnibox suggestion ‚Üí URL navigation path, this predictor is a key piece of that chain: it turns suggestion user‚Äêtext + URL into a speculation trigger. If you modify how suggestions are generated, you may affect the predictor performance and prerendering behaviour.

Because the predictor learns from user behaviour (hits/misses), in an Android WebView scenario if you have your own address bar logic you may need to ensure you log ‚Äúomnibox accepted‚Äù events (similar to OnOmniboxOpenedUrl) so the predictor database can keep up to date.



---

If you like, I can walk through the full code path including how PrerenderManager handles AddPrerenderFromOmnibox, what session storage namespace does, what cancellation looks like, and how activation works (hidden page ‚Üí visible) ‚Äî with links to the exact files. Would that be helpful for your WebView / Android integration scenario?
