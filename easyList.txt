struct CosmeticRule {
    WTF::String domain;   // empty if global
    CSSSelectorList selector;
    bool is_exception;
};

Vector<CosmeticRule> gParsedCosmeticFilters;

void InitCosmeticFilters() {
    for (auto& rule : kCosmeticFilters) {
        CosmeticRule parsed;
        parsed.is_exception = rule.Contains("#@#");
        
        auto parts = rule.Split("##");
        if (parts.size() == 2) {
            parsed.domain = parts[0];   // may be empty
            auto selector_str = parts[1];

            // Use Blink’s CSS selector parser
            parsed.selector = CSSParser::ParseSelector(selector_str, /*context*/nullptr);
        }
        gParsedCosmeticFilters.push_back(std::move(parsed));
    }
}


Vector<const CosmeticRule*> active_rules;

void Document::SetupCosmeticRules() {
    String host = this->Url().Host();
    active_rules.clear();

    for (auto& rule : gParsedCosmeticFilters) {
        if (rule.domain.IsEmpty() || host.EndsWith(rule.domain))
            active_rules.push_back(&rule);
    }
}


void Document::TraverseElements() {
    Element* el = ...;
    for (auto* rule : active_rules) {
        if (SelectorChecker::Matches(el, rule->selector)) {
            if (!rule->is_exception) {
                el->SetInlineStyleProperty(CSSPropertyID::kDisplay, "none");
            }
            // if it's an exception rule, skip hiding
        }
    }
}


#include "CosmeticFilters.h"  // generated from EasyList
#include "core/css/parser/CSSParser.h"
#include "core/css/SelectorChecker.h"
#include "core/dom/Element.h"
#include "platform/wtf/text/WTFString.h"
static void InitCosmeticFilters() {
    if (!gParsedCosmeticFilters.IsEmpty())
        return; // already parsed

    for (const auto& rule_str : blink::kCosmeticFilters) {
        CosmeticRule rule;

        // Exception rules use #@#
        rule.is_exception = rule_str.Contains("#@#");

        // Split domain + selector
        size_t pos = rule_str.find("##");
        if (pos == WTF::kNotFound) 
            pos = rule_str.find("#@#");
        if (pos == WTF::kNotFound)
            continue;

        rule.domain = rule_str.Substring(0, pos).StripWhiteSpace();
        WTF::String selector_str = rule_str.Substring(pos + (rule.is_exception ? 3 : 2));

        // Parse into CSSSelectorList
        CSSParserContext context(StrictCSSParserContext(UASheetMode));
        rule.selector = CSSParser::ParseSelector(selector_str, context);

        if (!rule.selector.IsEmpty())
            gParsedCosmeticFilters.push_back(std::move(rule));
    }
}

Vector<const CosmeticRule*> active_rules_;

void Document::SetupCosmeticRules() {
    InitCosmeticFilters();

    String host = Url().Host();
    active_rules_.clear();

    for (auto& rule : gParsedCosmeticFilters) {
        if (rule.domain.IsEmpty() || host.EndsWith(rule.domain)) {
            active_rules_.push_back(&rule);
        }
    }
}

void Document::TraverseElements() {
    for (Element* el = this->body()->firstElementChild(); 
         el; 
         el = el->NextElementSibling()) {

        for (auto* rule : active_rules_) {
            if (SelectorChecker::Matches(*el, rule->selector, SelectorChecker::kStandardMatch)) {
                if (!rule->is_exception) {
                    // Hide the element
                    el->setInlineStyleProperty(CSSPropertyDisplay, "none", SecureContextMode::kNotSecureContext);
                }
                // else → skip hiding (exception)
            }
        }
    }
}

